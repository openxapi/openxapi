{{>partial_header}}
package {{packageName}}

import (
	"context"
	"crypto"
	"crypto/ed25519"
	"crypto/hmac"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/base64"
	"encoding/pem"
	"fmt"
	"net/http"
	"io"
	"os"
)

type BinanceKeyType string

const (
	BinanceKeyTypeHMAC    BinanceKeyType = "HMAC"
	BinanceKeyTypeRSA                    = "RSA"
	BinanceKeyTypeED25519                = "ED25519"
)

func NewBinanceAuth(apiKey string, keyType BinanceKeyType) *BinanceAuth {
	return &BinanceAuth{
		APIKey:  apiKey,
		KeyType: keyType,
	}
}

// BinanceAuth provides Binance API key based authentication to a request passed via context using ContextBinanceAuth
type BinanceAuth struct {
	APIKey           string
    KeyType          BinanceKeyType
    PrivateKeyPath   string    // The path to the private key.
    PrivateKeyReader io.Reader // provide the APIKey using the types which implement io.Reader interface.
    Passphrase       string    // The passphrase to decrypt the private key, if the key is encrypted.
    privateKey       crypto.PrivateKey
    secretKey        string
}

func (b *BinanceAuth) SetSecretKey(secretKey string) {
	b.secretKey = secretKey
}

// SetPrivateKey accepts a private key string and sets it.
func (b *BinanceAuth) SetPrivateKey(privateKey []byte) error {
	return b.parsePrivateKey(privateKey)
}

// ContextWithValue validates the BinanceAuth configuration parameters and returns a context
// suitable for HTTP signature. An error is returned if the BinanceAuth configuration parameters
// are invalid.
func (b *BinanceAuth) ContextWithValue(ctx context.Context) (context.Context, error) {
	if b.APIKey == "" {
		return nil, fmt.Errorf("APIKey must be specified")
	}
	if b.KeyType == BinanceKeyTypeHMAC && len(b.secretKey) == 0 {
		return nil, fmt.Errorf("secretKey must be specified for %s API key", BinanceKeyTypeHMAC)
	}
	if b.KeyType == BinanceKeyTypeRSA || b.KeyType == BinanceKeyTypeED25519 {
		if (len(b.PrivateKeyPath) == 0 && b.PrivateKeyReader == nil) && b.privateKey == nil {
			return nil, fmt.Errorf("private key path must be specified")
		}
		if len(b.PrivateKeyPath) > 0 && b.PrivateKeyReader != nil {
			return nil, fmt.Errorf("Specify only one of PrivateKeyPath or PrivateKeyReader")
		}
		if err := b.loadPrivateKey(); err != nil {
			return nil, err
		}
	}
	return context.WithValue(ctx, ContextBinanceAuth, *b), nil
}

// loadPrivateKey reads the private key from the file specified in the BinanceAPIKey.
// The key is loaded only when privateKey is not already set.
func (b *BinanceAuth) loadPrivateKey() (err error) {
	if b.privateKey != nil {
		return nil
	}
	var priv []byte
	keyReader := b.PrivateKeyReader
	if keyReader == nil {
		var file *os.File
		file, err = os.Open(b.PrivateKeyPath)
		if err != nil {
			return fmt.Errorf("cannot load private key '%s'. Error: %v", b.PrivateKeyPath, err)
		}
		keyReader = file
		defer func() {
			err = file.Close()
		}()
	}
	priv, err = io.ReadAll(keyReader)
	if err != nil {
		return err
	}
	return b.parsePrivateKey(priv)
}

// parsePrivateKey decodes privateKey byte array to crypto.PrivateKey type.
func (b *BinanceAuth) parsePrivateKey(priv []byte) error {
	pemBlock, _ := pem.Decode(priv)
	if pemBlock == nil {
		// No PEM data has been found.
		return fmt.Errorf("file '%s' does not contain PEM data", b.PrivateKeyPath)
	}
	var privKey []byte
	var err error
	if x509.IsEncryptedPEMBlock(pemBlock) {
		// The PEM data is encrypted.
		privKey, err = x509.DecryptPEMBlock(pemBlock, []byte(b.Passphrase))
		if err != nil {
			// Failed to decrypt PEM block. Because of deficiencies in the encrypted-PEM format,
			// it's not always possible to detect an incorrect password.
			return err
		}
	} else {
		privKey = pemBlock.Bytes
	}
	switch pemBlock.Type {
	case "RSA PRIVATE KEY":
		if b.privateKey, err = x509.ParsePKCS1PrivateKey(privKey); err != nil {
			return err
		}
	case "EC PRIVATE KEY", "PRIVATE KEY":
		// https://tools.ietf.org/html/rfc5915 section 4.
		if b.privateKey, err = x509.ParsePKCS8PrivateKey(privKey); err != nil {
			return err
		}
	default:
		return fmt.Errorf("key '%s' is not supported", pemBlock.Type)
	}
	return nil
}

func (b *BinanceAuth) Sign(r *http.Request) (err error) {
	q := r.URL.Query()
	queryString := q.Encode()
	var dataToSign []byte
	if r.Body != nil {
		reader, err := r.GetBody()
		if err != nil {
			return fmt.Errorf("failed to get request body: %s", err)
		}
		bodyData, err := io.ReadAll(reader)
		if err != nil {
			return fmt.Errorf("failed to read request body: %s", err)
		}
		// If we have both query parameters and body data, concatenate them properly
		if queryString != "" {
			dataToSign = []byte(queryString)
			if len(bodyData) > 0 {
				dataToSign = append(dataToSign, bodyData...)
			}
		} else {
			dataToSign = bodyData
		}
	} else {
		// No body, just use query parameters
		dataToSign = []byte(queryString)
	}
	var signature string
	switch b.KeyType {
	case BinanceKeyTypeHMAC:
		mac := hmac.New(sha256.New, []byte(b.secretKey))
		_, err = mac.Write(dataToSign)
		if err != nil {
			return err
		}
		signature = fmt.Sprintf("%x", (mac.Sum(nil)))
	case BinanceKeyTypeRSA:
		privKey, ok := b.privateKey.(*rsa.PrivateKey)
		if !ok {
			return fmt.Errorf("invalid RSA privateKey")
		}
		hashed := sha256.Sum256(dataToSign)
		bs, err := rsa.SignPKCS1v15(rand.Reader, privKey, crypto.SHA256, hashed[:])
		if err != nil {
			return err
		}
		signature = base64.StdEncoding.EncodeToString(bs)
	case BinanceKeyTypeED25519:
		privKey, ok := b.privateKey.(ed25519.PrivateKey)
		if !ok {
			return fmt.Errorf("invalid Ed25519 privateKey")
		}
		signature = base64.StdEncoding.EncodeToString(ed25519.Sign(privKey, dataToSign))
	default:
	    return fmt.Errorf("unsupported binance key type: %s", b.KeyType)
	}
	q.Add("signature", signature)
	r.URL.RawQuery = q.Encode()
	return nil
}
