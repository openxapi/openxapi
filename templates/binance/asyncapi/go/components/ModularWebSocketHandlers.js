/*
 * Modular WebSocket Handlers component that delegates to module-specific implementations
 * This allows each module to have its own dedicated generation logic
 */

import { getModuleConfig, detectModuleName } from './ModuleRegistry.js';
import { WebSocketHandlers } from './WebSocketHandlers.js';

export function ModularWebSocketHandlers({ asyncapi, context = {} }) {
  // Detect which module we're generating for
  const moduleName = detectModuleName(asyncapi, context);
  
  // Get the module-specific configuration
  const moduleConfig = getModuleConfig(moduleName);
  
  // Use the module-specific WebSocket handlers generator
  try {
    return moduleConfig.handlers.webSocketHandlers(asyncapi, moduleConfig);
  } catch (error) {
    console.warn(`Module-specific handler failed for ${moduleName}: ${error.message}`);
    // Final fallback - generate basic client methods WITH models import
    return generateBasicClientMethodsWithModels(moduleName);
  }
}

/*
 * Generate basic client methods as a final fallback
 */
function generateBasicClientMethods(moduleName) {
  return `// Basic client methods for ${moduleName} module
// Generated due to missing WebSocketHandlers component

// GetModuleName returns the module name
func (c *Client) GetModuleName() string {
	return "${moduleName}"
}

// Ping sends a ping request to test connectivity
func (c *Client) Ping(ctx context.Context) error {
	if c.conn == nil {
		return fmt.Errorf("not connected")
	}
	
	request := map[string]interface{}{
		"id":     GenerateRequestID(),
		"method": "ping",
	}
	
	return c.sendRequest(request)
}`;
}

/*
 * Generate basic client methods with models import as a final fallback
 */
function generateBasicClientMethodsWithModels(moduleName) {
  return `// Basic client methods for ${moduleName} module
// Generated due to missing WebSocketHandlers component

// GetModuleName returns the module name
func (c *Client) GetModuleName() string {
	return "${moduleName}"
}

// Ping sends a ping request to test connectivity
func (c *Client) Ping(ctx context.Context) error {
	if c.conn == nil {
		return fmt.Errorf("not connected")
	}
	
	request := map[string]interface{}{
		"id":     GenerateRequestID(),
		"method": "ping",
	}
	
	return c.sendRequest(request)
}

// Template placeholder for request/response methods
// These methods should be generated by the WebSocketHandlers component
// but are missing due to template loading issues

// SendPing sends a ping request using typed request/response structs
func (c *Client) SendPing(ctx context.Context, request *models.PingRequest, responseHandler func(*models.PingResponse, error) error) error {
	return fmt.Errorf("SendPing method not implemented - WebSocketHandlers component missing")
}

// SendTime sends a time request using typed request/response structs
func (c *Client) SendTime(ctx context.Context, request *models.TimeRequest, responseHandler func(*models.TimeResponse, error) error) error {
	return fmt.Errorf("SendTime method not implemented - WebSocketHandlers component missing")
}

// SendExchangeInfo sends an exchange info request using typed request/response structs
func (c *Client) SendExchangeInfo(ctx context.Context, request *models.ExchangeInfoRequest, responseHandler func(*models.ExchangeInfoResponse, error) error) error {
	return fmt.Errorf("SendExchangeInfo method not implemented - WebSocketHandlers component missing")
}

// Basic event handler registration methods
func (c *Client) HandleEventStreamTerminatedEvent(handler func(event *models.EventStreamTerminated) error) {
	// Empty implementation - should be generated by WebSocketHandlers
}

func (c *Client) HandleOutboundAccountPositionEvent(handler func(event *models.OutboundAccountPosition) error) {
	// Empty implementation - should be generated by WebSocketHandlers  
}

func (c *Client) HandleBalanceUpdateEvent(handler func(event *models.BalanceUpdate) error) {
	// Empty implementation - should be generated by WebSocketHandlers
}

func (c *Client) HandleExecutionReportEvent(handler func(event *models.ExecutionReport) error) {
	// Empty implementation - should be generated by WebSocketHandlers
}

func (c *Client) HandleListStatusEvent(handler func(event *models.ListStatus) error) {
	// Empty implementation - should be generated by WebSocketHandlers
}

func (c *Client) HandleListenKeyExpiredEvent(handler func(event *models.ListenKeyExpired) error) {
	// Empty implementation - should be generated by WebSocketHandlers
}

func (c *Client) HandleExternalLockUpdateEvent(handler func(event *models.ExternalLockUpdate) error) {
	// Empty implementation - should be generated by WebSocketHandlers
}`;
}

/*
 * Enhanced WebSocketHandlers with module-specific awareness
 * This extends the original WebSocketHandlers with module-specific customizations
 */
export function EnhancedWebSocketHandlers({ asyncapi, moduleName = null }) {
  const detectedModule = moduleName || detectModuleName(asyncapi, {});
  const moduleConfig = getModuleConfig(detectedModule);
  
  // Generate standard handlers using the original logic
  let handlers;
  try {
    handlers = WebSocketHandlers({ asyncapi });
  } catch (error) {
    console.warn('Could not load WebSocketHandlers component:', error.message);
    handlers = '// WebSocketHandlers component not available\n';
  }
  
  // Add module-specific customizations
  handlers += generateModuleSpecificMethods(asyncapi, detectedModule, moduleConfig);
  
  return handlers;
}

/*
 * Generate module-specific methods and customizations
 */
function generateModuleSpecificMethods(asyncapi, moduleName, moduleConfig) {
  let moduleSpecificCode = '';
  
  moduleSpecificCode += `// Module-specific methods for ${moduleName}\n`;
  moduleSpecificCode += `// Generated with module configuration: ${JSON.stringify(moduleConfig.name)}\n\n`;
  
  // Add module-specific convenience methods
  switch (moduleName) {
    case 'spot':
      moduleSpecificCode += generateSpotSpecificMethods(asyncapi, moduleConfig);
      break;
    case 'umfutures':
      moduleSpecificCode += generateUmfuturesSpecificMethods(asyncapi, moduleConfig);
      break;
    case 'cmfutures':
      moduleSpecificCode += generateCmfuturesSpecificMethods(asyncapi, moduleConfig);
      break;
    default:
      moduleSpecificCode += generateDefaultModuleMethods(asyncapi, moduleConfig);
  }
  
  return moduleSpecificCode;
}

/*
 * Generate spot-specific methods
 */
function generateSpotSpecificMethods(asyncapi, moduleConfig) {
  let methods = '';
  
  methods += `// GetSpotMarketData retrieves current spot market data\n`;
  methods += `func (c *Client) GetSpotMarketData(ctx context.Context, symbol string) error {\n`;
  methods += `\t// Implementation for spot market data retrieval\n`;
  methods += `\treturn nil\n`;
  methods += `}\n\n`;
  
  // Add spot-specific trading methods
  methods += `// PlaceSpotOrder places a spot trading order\n`;
  methods += `func (c *Client) PlaceSpotOrder(ctx context.Context, symbol, side, orderType string, quantity float64) error {\n`;
  methods += `\t// Implementation for spot order placement\n`;
  methods += `\treturn nil\n`;
  methods += `}\n\n`;
  
  return methods;
}

/*
 * Generate USD-M futures specific methods
 */
function generateUmfuturesSpecificMethods(asyncapi, moduleConfig) {
  let methods = '';
  
  methods += `// GetFuturesPositions retrieves current futures positions\n`;
  methods += `func (c *Client) GetFuturesPositions(ctx context.Context) error {\n`;
  methods += `\t// Implementation for futures positions retrieval\n`;
  methods += `\treturn nil\n`;
  methods += `}\n\n`;
  
  methods += `// SetLeverage sets leverage for a futures symbol\n`;
  methods += `func (c *Client) SetLeverage(ctx context.Context, symbol string, leverage int) error {\n`;
  methods += `\t// Implementation for leverage setting\n`;
  methods += `\treturn nil\n`;
  methods += `}\n\n`;
  
  return methods;
}

/*
 * Generate COIN-M futures specific methods
 */
function generateCmfuturesSpecificMethods(asyncapi, moduleConfig) {
  let methods = '';
  
  methods += `// GetCoinMFuturesPositions retrieves current COIN-M futures positions\n`;
  methods += `func (c *Client) GetCoinMFuturesPositions(ctx context.Context) error {\n`;
  methods += `\t// Implementation for COIN-M futures positions retrieval\n`;
  methods += `\treturn nil\n`;
  methods += `}\n\n`;
  
  methods += `// SetCoinMMarginType sets margin type for COIN-M futures\n`;
  methods += `func (c *Client) SetCoinMMarginType(ctx context.Context, symbol, marginType string) error {\n`;
  methods += `\t// Implementation for COIN-M margin type setting\n`;
  methods += `\treturn nil\n`;
  methods += `}\n\n`;
  
  return methods;
}

/*
 * Generate default module methods (fallback)
 */
function generateDefaultModuleMethods(asyncapi, moduleConfig) {
  let methods = '';
  
  methods += `// GetModuleInfo returns information about the current module\n`;
  methods += `func (c *Client) GetModuleInfo() string {\n`;
  methods += `\treturn "Module: ${moduleConfig.name}"\n`;
  methods += `}\n\n`;
  
  return methods;
}